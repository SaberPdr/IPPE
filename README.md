**B. 内积谓词加密**

内积谓词加密（Inner Product Predicate Encryption，PPE）方案包含一个秘密密钥为 8k。
对于输入的字符 $I\in\Sigma$，输出密文 $ctr$。
加密过程 $Encrypt(sk,I)$：输入秘密密钥 $sk$ 和明文 $I$，输出密文 $ctr$。
生成搜索令牌过程 $GenToken(sk,q)$：输入秘密密钥 $sk$ 和谓词 $q\in Q$，输出搜索令牌 $st$。
查询过程 $Query(st_q,ctr)$：输入谓词 $q$ 的搜索令牌 $st$ 和明文 $I$ 的密文 $ct$，输出 $q(x)\in\{0,1\}$。

正确性：为了保证正确性，内积谓词加密需要满足以下条件。对于所有的 $A,I\in\Sigma$ 和 $q\in Q$，令 $Encrypt(8k,I)$，$k\leftarrow Setup(12)$，$st\leftarrow GenToken(sk,q)$ 和 $c\leftarrow -$。如果 $<I,q>=0$，那么 $Query(st_q,ctr)=1$。如果 $<I,q>\neq0$，那么 $Pr[Query(st_v,ctr))\geq1-\delta(\lambda)$，其中 $\delta$ 是一个可忽略函数。

**C. 定制代理重加密**

基于[41]，我们的定制代理重加密（Tailored Proxy re-encryption，TPR）由四个算法组成，即 $TPR=(KeyGen,Rnd,RecKeyGen,ReEnc)$。我们定义 $Hc$ 是一个伪随机函数：$\{0,1\}^*\to G$，其中 $G$ 是一个 $q$ 阶有限群。下面描述 $TPR$：
- $KeyGen(1)$：这个算法将生成一个秘密密钥。输入安全参数，输出一个随机数 $rk$ 作为秘密密钥，其中 $rk\in Z_p$。
- $Rnd(m,rk)$：这个算法将随机化消息 $m$。输入消息 $m$ 和秘密密钥 $rk$，输出一个伪随机字符串 $ps$，其中 $ps = Hc(mm)r$。
- $RecKeyGen(rk_1,rk_2)$：这个算法将生成重加密密钥。输入秘密密钥 $rk_1$ 和 $rk_2$，输出重加密密钥 $rk_12$，其中 $rk_1→2 = rk2/rk1$。
- $ReEnc(ps_1,rk_1→2)$：这个算法将执行代理重加密。输入 $ps_1$，输出在 $rk_1→2$ 下的重加密消息 $ps_2$，其中 $ps_2 = ps12→→2$。

**IV. 问题公式化**

在介绍我们提出的 CFB-DSSE 之前，我们提供了一个符号列表，如表 I 所示。这些符号将在我们后续的模型和构造中使用。

**A. 系统模型**

系统模型如图 2 所示。我们的方案中有三个参与方，数据所有者（Data Owner，DO）、数据用户（Data User，DU）和云服务器（Cloud Server，CS）。我们认为数据所有者和数据用户是完全可信的，而云服务器是诚实但好奇的。

数据所有者：数据所有者通过智能金融系统中的物联网设备保存金融数据。然后，数据所有者生成索引，并将加密后的金融数据和索引外包给云服务器。在更新和搜索过程中，数据所有者生成更新/搜索令牌并发送给云服务器。

|符号|描述|
|---|---|
|$W$|关键字集合|
|$E$|$W$中的关键字，其中 $i = 1...n$|
|$|W|$|关键字的数量|
|$ind$|文件的标识符|
|$|$|文件集合|
|$find$|文件集合中的文件，其中 $ind = 1...m$|
|$F$|文件的数量|
|$DB(w)$|包含关键字 $w$ 的文档集合|
|$cph$|加密文件|
|$c$|计数器|
|$ak$|内积谓词加密的秘密密钥 $ak$|
|$rk$|定制代理重加密的秘密密钥 $rk$|
|$e$|未加密的明文位图索引|
|$C_i$|用 $ak$ 加密的位图索引|
|$Cr$|用 $rk$ 加密的位图索引|
|$CTw$|关键字 $w$ 的关键字索引|
|$CTind$|文件 $find$ 的文件索引|
|$LM$|存储关键字和关键字索引的映射|
|$LM_f$|存储文件和文件索引的映射|
|$UT$|更新令牌|
|$ST$|搜索令牌|
|$kf$|用于加密文件的密钥|
|$ku$|用于加密关键字的密钥|
|$kind$|用于加密文件标识符 $ind$ 的密钥|
|$<$|内积操作|

云服务器：云服务器负责存储金融数据，并在接收令牌后执行相应的更新/搜索操作。

数据用户：数据用户通过智能金融系统中的物联网设备查看金融数据。在搜索过程中，数据用户将搜索令牌发送给云服务器，其中搜索令牌是从数据所有者处获得的。然后，云服务器将相应的搜索结果返回给数据用户。

**初始化执行**

**算法 1 设置**

客户端：
1. $EDB\leftarrow -el+$；对于 $i = 1$ 到 $n$，执行 $2k+(0,1)$，$k_m\leftarrow F_w$，$k_md\leftarrow F_k(ind)$；$c\leftarrow0$；$CTw\leftarrow F_k(w)$；
2. $LM+(tCT)$；
3. 结束循环；
4. 对于 $ind = 1$ 到 $m$，执行 $LM_f+(f_n,CTindj)$；$CInd\leftarrow F_k(ind)$；
5. 将 $EDB$ 发送到云服务器；
6. $sk\leftarrow IPPE.Setup(1)$；
7. $rk\leftarrow TPR.KeyGen(1)$；

**算法 2 加密**

输入未加密的位图索引 $e$、秘密密钥 $rk$ 和文件集 $f$。

客户端：
1. 从文件集 $f=\{1...m\}$ 中提取关键字 $w$；
2. 对于 $i = 1$ 到 $n$，执行 $CTw+LMw$；
3. 对于 $ind = 1$ 到 $m$，如果 $w$ 出现在 $f$ 中，则执行以下操作；
4. 结束循环；
5. $[e,e]\leftarrow IPPE.Enc(sk,e)$；
6. $[I,I]\leftarrow TPR.Rnd(e,rk_1)$；
7. $CTi\leftarrow LW:(TCT+1$；
8. $cph\leftarrow Enc(k,f_m)$；
9. 将 $I_1=(I,I)$ 和 $cph$ 发送到云服务器。

更新算法：最后，数据所有者将 $EDB$ 发送到云服务器，并将 $\sigma=(LMw,LM_f,c),k,rk$ 保密。详细算法如算法 1 所示。
1. **加密阶段**：数据所有者执行加密算法来加密位图索引 $e$ 和文件集 $f$。数据所有者首先从文件集 $f_1...f_m$ 中提取关键字，然后生成未加密的位图索引 $e[e,e]$，如算法 2 的第 2 - 11 行所示。之后，数据所有者首先使用秘密密钥 $sk$ 对位图索引 $e[e,e]$ 进行加密，并获得第一次加密后的索引 $e[e,e]$，为后续的合取查询提供基础。为了确保前向安全性，数据所有者将使用重加密密钥 $rk_i$ 对位图索引 $e[e,e]$ 进行加密，获得索引 $I[e,e]$（算法 2 的第 12、13 行）。数据所有者使用文件密钥对文件进行加密，其中文件密钥 $k$ 使用诸如 AES 等对称加密算法对文件进行加密。最后，数据所有者将密文 $cph$ 和 $I_1=(I,I)$ 发送到云服务器。
2. **更新阶段**：数据所有者执行更新算法来添加和删除文件。要添加一个文件，数据所有者首先从 $LM_s$ 和 $LM_w$ 中分别获取当前文件索引 $CTind$ 和关键字索引 $CT$。然后，数据所有者从更新的文件中提取关键字，并构建未加密的位图索引 $c[e,CTind]$。如果文档包含关键字，则相应位置设置为 1，否则设置为 0。之后，数据所有者使用 $IPPE.Enc$ 算法对位图索引进行加密，形成 $e[e,CTind]$，并应用 $TPR.Rnd$ 进一步加密，创建 $I[e,CTind]$。数据所有者对更新的文件进行加密，并生成新的 $TPR$ 密钥 $rk_2$ 和重加密密钥 $rk_1→2$（见算法 3 的第 14 - 17 行）。然后，文件索引 $CTind$ 和加密索引 $I[e,CTind]$ 形成更新令牌 $UT$。最后，数据所有者将更新令牌 $UT$、重加密密钥 $rk1d$ 和加密文件 $cph$ 发送到云服务器。云服务器使用更新令牌中的 $CTind$ 替换原始索引 $I,CTin$ 为 $I[e,CTin]$。同时，云服务器执行 $TPR.ReEnc$ 对所有索引 $I[e,e]$ 进行重加密，这可以确保前向安全性。因为索引已经使用 $rk_2$ 进行了重加密，所以包含 $rk$ 的先前搜索令牌 $ST$ 不能解密当前索引，使得先前的搜索令牌对于合取查询无效。

对于删除操作，数据所有者按照与添加操作相同的步骤生成更新令牌 $UT$、重加密密钥 $rk12$ 和加密文件 $cph$。然后，数据所有者将它们发送到云服务器（见算法 3 的第 24 - 38 行）。云服务器使用更新令牌中的文件索引 $CTim$ 获得相应的加密位图索引 $I[e,CTin]$，并从 $I[e,e]$ 中删除它。同时，云服务器在删除 $I[e,CTim]$ 后，使用重加密密钥 $rk1→2$ 对所有剩余索引进行加密。这确保了后向安全性，因为用户的先前搜索令牌不能用于对已删除的索引执行合取查询。此外，由于与上述相同的原因，它也确保了前向安全性。
3. **搜索阶段**：当数据所有者收到来自医疗机构或医生的搜索请求时，数据所有者调用 $IPPE.GenToken$ 生成一个内积谓词加密令牌 $st_q$。然后，数据所有者将搜索令牌 $ST$ 发送给数据用户，其中搜索令牌 $ST$ 由 $st_Q$ 和当前更新密钥 $rkc + 1$ 组成。之后，数据用户将搜索令牌发送到云服务器。当云服务器接收到搜索令牌时，它使用 $rkc + 1$ 解密索引 $I[e,e]$，获得 $e[e,e]$。然后，云服务器

**算法定义**

1. `Setup(1,DB)→(EDB,σ=(LMw,LMc))`：客户端执行此算法。输入安全参数和数据库，输出加密数据库、空映射 $LMw$、$LMc$ 和空计数器 $c$。
2. `Enc(c,F,sk,rk,ky)→(Il,cph)`：客户端执行此算法。输入未加密的位图索引、由内积谓词加密算法生成的秘密密钥、由定制代理重加密生成的秘密密钥和文件集。然后客户端将输出加密文件、文件索引和加密后的位图索引 $I_1=(CTind,I)$，其中 $I_1=(CTind,I)$。
3. `Update(wi,f_ind,e,σ,EDB,UT)`：客户端和云服务器执行此算法。输入更新的关键字、文件标识符、未加密的位图索引、状态和加密数据库。云服务器将输出更新后的数据库、状态和加密文件。
4. `Search(ST,EDB,σ,q)→CTind`：客户端和云服务器执行此算法。输入搜索令牌、加密数据库、状态和查询，其中查询 $q=(A\wedge\cdots\wedge w)$。云服务器输出搜索结果 $CTind$。

**A. 位图索引**

在本文中，我们使用位图索引作为一种索引结构来描述文件和关键字之间的关系。位图利用位来存储信息。我们考虑文件的最大关键字数量为 $\ell$，如果文件包含这个关键字，关键字的位串中的相应位置为 1，否则为 0。如图 1（a）所示，我们使用一个具体的例子来说明。我们考虑位图索引的位长度为 5。因此，$f_1,f_2,f_3$ 分别包含关键字 $(w,w2,(1,2,4))$ 和 $(w,w2,13)$。当客户端执行搜索算法时，我们构建合取查询 $q$ 为与位图索引长度相同的位串。如图 1（b）所示，当我们查询 $t\wedge w_1\wedge w_2$ 时，我们对合取查询 $q$ 和位图索引执行内积操作。然后，我们可以得到最终的搜索结果 $f_1$。

**A. 概述**

在 CFB-DSSE 方案中，数据所有者最初执行设置算法，然后通过从要外包的文件中提取关键字生成位图索引。随后，数据所有者使用内积谓词加密和定制代理重加密对位图索引进行双层加密。加密后的索引和文件被外包给云服务器。在更新算法中，数据所有者将更新令牌发送到云服务器。然后云服务器接受更新令牌并执行相应的操作。更新后的索引使用重加密密钥进行加密，打破了先前搜索令牌与当前索引之间的链接，确保了前向和后向安全性。在搜索算法中，当数据所有者收到来自数据用户的搜索请求时，他们为他们生成搜索令牌。数据用户可以通过将令牌发送到云服务器来执行合取查询并检索相关的金融数据。

**B. 方案构造**

我们将详细描述我们的方案，它由四个阶段组成。分别是设置阶段、加密阶段、更新阶段和搜索阶段。
1. **设置阶段**：数据所有者输入安全参数执行设置算法。$F$ 是一个伪随机函数。$[e,CTind]$ 表示文件 $find$ 的位图索引，$[CTw,Tind]$ 表示文件 $find$ 中关键字 $w_i$ 的位置。首先初始化位图索引 $e[e,e]$、空映射 $EDB$，并将计数器值设置为 0。然后数据所有者随机选择一个密钥 $k\in\{0,1\}$，并利用伪随机函数 $F$ 生成关键字密钥 $k_w$ 和文件标识符密钥 $kind$。对于每个关键字，数据所有者使用伪随机函数 $F$ 在 $k_w$ 下生成关键字索引，并将关键字 $w_i$ 和相应的关键字索引 $CT$ 存储在映射 $LM$ 中。对于每个文件，数据所有者使用伪随机函数 $F$ 在 $k$ 下生成文件索引，并将文件标识符 $ind$ 和相应的文件索引 $CTind$ 存储在映射 $LM_f$ 中。之后，数据所有者分别执行内积谓词加密（IPPE.Setup）和定制代理重加密（TPR.KeyGen）算法，其中 $sk$ 用于加密位图索引并执行合取查询，$rk$ 用于加密和重加密。

**算法 4：搜索**

输出：搜索结果。

输入：搜索令牌 $ST$、加密数据库 $EDB$、状态 $\sigma$ 和查询 $q=(w1\wedge w_2\wedge\cdots\wedge w_t)$。

客户端：
1. $s_g\leftarrow IPPE.GenToken(sk,q)$；
2. $ST\leftarrow(s_g,rk_c + 1)$；
3. 将搜索令牌 $ST$ 发送到云服务器；

云服务器：
1. 从客户端接收 $ST$；
2. $[e,e]\leftarrow Dec(I,rkc + 1)$；
3. 如果 $Query(st_q,e[e,e])=1$，则执行以下操作；
4. 返回 $CTind$ 给客户端；
5. 否则；
6. 返回 $\perp$ 给客户端；

详细过程如算法 4 所示。

**算法 3：更新**

输入：更新的关键字 $w$、文件 $find$、未加密的位图索引 $e[e,e]$、加密数据库 $EDB$ 和更新令牌 $UT$。

输出：更新后的数据库 $EDB'$、状态 $\sigma'$ 和加密文件 $cph$。

客户端：
1. $cph\leftarrow cph\cup cph$；
2. 如果操作是删除（op = del），则执行以下操作；
3. $CTind\leftarrow LMf$；
4. 从 $find$ 中提取关键字 $ww$，并将 $e[e,CTind]\leftarrow0$；
5. 对于 $i = 1$ 到 $s$，执行以下操作；
6. $CT\leftarrow LMw$；
7. 如果 $w$ 出现在 $f$ 中，则执行以下操作；
8. $e[e,CTind]\leftarrow0$；
9. 结束循环；
10. $e[e,CTind]\leftarrow1$；
11. 结束循环；
12. $e[e,CTind]\leftarrow IPPE.Enc(sk,e)$；
13. $I[e,CTind]\leftarrow TPR.Rnd(e,rk_1)$；
14. $cph\leftarrow Enc(k_s,f_{ind})$；
15. $c\leftarrow c + 1$；
16. $rk_2\leftarrow H(rk_1,c)$；
17. $rk_1\rightarrow2\leftarrow TPR.RecKeyGen(rk_1,rk_2)$；
18. $UT\leftarrow(CTind,I)$；
19. 将 $UT$、$rk_1\rightarrow2$、$cph$发送到云服务器，其中 $UT=(CTind,I)$；

服务器端：
1. 设置 $I[e,CTind]\leftarrow I[e,CTimd]$；
2. $I[e,e]\leftarrow TPR.ReEnc(I[e,e],rk_1\rightarrow2)$；
3. $cph\leftarrow cph\cup cph$；

算法 4：搜索

输出：搜索结果。

输入：搜索令牌 $ST$、加密数据库 $EDB$、状态 $\sigma$ 和查询 $q=(w_1\wedge w_2\wedge\cdots\wedge w_t)$。

客户端：
1. $s_g\leftarrow IPPE.GenToken(sk,q)$；
2. $ST\leftarrow(s_g,rk_{c + 1})$；
3. 将搜索令牌 $ST$ 发送到云服务器；

服务器端：
1. 从客户端接收 $ST$；
2. $[e,e]\leftarrow Dec(I,rk_{c + 1})$；
3. 如果 $Query(st_q,[e,e])=1$，则执行以下操作；
4. 返回 $CTind$ 给客户端；
5. 否则；
6. 返回 $\perp$ 给客户端。
